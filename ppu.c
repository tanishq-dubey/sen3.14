#include "ppu.h"
#include "memory.h"

static unsigned char default_palette [32] = {
    0x09, 0x01, 0x00, 0x01,
    0x00, 0x02, 0x02, 0x0D,
    0x08, 0x10, 0x08, 0x24,
    0x00, 0x00, 0x04, 0x2C,
    0x09, 0x01, 0x34, 0x03,
    0x00, 0x04, 0x00, 0x14,
    0x08, 0x3A, 0x00, 0x02,
    0x00, 0x20, 0x2C, 0x08,
};
static unsigned char nes_palette[64][3] =
{
   {0x80,0x80,0x80}, {0x00,0x00,0xBB}, {0x37,0x00,0xBF}, {0x84,0x00,0xA6},
   {0xBB,0x00,0x6A}, {0xB7,0x00,0x1E}, {0xB3,0x00,0x00}, {0x91,0x26,0x00},
   {0x7B,0x2B,0x00}, {0x00,0x3E,0x00}, {0x00,0x48,0x0D}, {0x00,0x3C,0x22},
   {0x00,0x2F,0x66}, {0x00,0x00,0x00}, {0x05,0x05,0x05}, {0x05,0x05,0x05},

   {0xC8,0xC8,0xC8}, {0x00,0x59,0xFF}, {0x44,0x3C,0xFF}, {0xB7,0x33,0xCC},
   {0xFF,0x33,0xAA}, {0xFF,0x37,0x5E}, {0xFF,0x37,0x1A}, {0xD5,0x4B,0x00},
   {0xC4,0x62,0x00}, {0x3C,0x7B,0x00}, {0x1E,0x84,0x15}, {0x00,0x95,0x66},
   {0x00,0x84,0xC4}, {0x11,0x11,0x11}, {0x09,0x09,0x09}, {0x09,0x09,0x09},

   {0xFF,0xFF,0xFF}, {0x00,0x95,0xFF}, {0x6F,0x84,0xFF}, {0xD5,0x6F,0xFF},
   {0xFF,0x77,0xCC}, {0xFF,0x6F,0x99}, {0xFF,0x7B,0x59}, {0xFF,0x91,0x5F},
   {0xFF,0xA2,0x33}, {0xA6,0xBF,0x00}, {0x51,0xD9,0x6A}, {0x4D,0xD5,0xAE},
   {0x00,0xD9,0xFF}, {0x66,0x66,0x66}, {0x0D,0x0D,0x0D}, {0x0D,0x0D,0x0D},

   {0xFF,0xFF,0xFF}, {0x84,0xBF,0xFF}, {0xBB,0xBB,0xFF}, {0xD0,0xBB,0xFF},
   {0xFF,0xBF,0xEA}, {0xFF,0xBF,0xCC}, {0xFF,0xC4,0xB7}, {0xFF,0xCC,0xAE},
   {0xFF,0xD9,0xA2}, {0xCC,0xE1,0x99}, {0xAE,0xEE,0xB7}, {0xAA,0xF7,0xEE},
   {0xB3,0xEE,0xFF}, {0xDD,0xDD,0xDD}, {0x11,0x11,0x11}, {0x11,0x11,0x11}
};

void init_ppu()
{
	//powerup state found at https://wiki.nesdev.com/w/index.php/PPU_power_up_state#Best_practice
	PPUCTRL = 0;
	PPUMASK = 0;
	PPUSTATUS = 0;
	OAMADDR = 0;
	OAMDATA = 0;
	PPUSCROLL = 0;
	PPUADDR = 0;
	PPUDATA = 0;

	x_or_y_scroll = true;
	x_offset = 0;
	y_offset = 0;

	addr_write = true;

	ppu_cycles = 0;

	PPU_VRAM_MEMORY = (uint8_t*)malloc(sizeof(uint8_t)*0x10000);
	PPU_OAM_MEMORY = (uint8_t*)malloc(sizeof(uint8_t)*256);

	if(debug)
	{
		debug_print("%s","\033[32;1mPPU Register Data:\033[0m\n");
        debug_print("0x2000: 0x%02x\n", PPUCTRL);
        debug_print("0x2001: 0x%02x\n", PPUMASK);
        debug_print("0x2002: 0x%02x\n", PPUSTATUS);
        debug_print("0x2003: 0x%02x\n", OAMADDR);
        debug_print("0x2004: 0x%02x\n", OAMDATA);
        debug_print("0x2005: 0x%02x\n", PPUSCROLL);
        debug_print("0x2006: 0x%02x\n", PPUADDR);
        debug_print("0x2007: 0x%02x\n", PPUDATA);
	}
} 

uint8_t ppu_read(uint16_t address)
{
	if(address == 0x2002) {
		return read_STATUS;
	}
	else if(address == 0x2004) {
		return read_OAMDATA;
	}
	else if(address == 0x2007) {
		return read_VRAMDATA;
	}

	return 0x00;
}

void ppu_write(uint16_t address, uint8_t value)
{
	if(address == 0x2000) {
		write_CTRL(value);
	}
	else if(address == 0x2001) {
		write_MASK(value);
	}
	else if (address == 0x2003) {
        write_OAMADDR(value);
    } 
    else if (address == 0x2004) {
        write_OAMDATA(value);
    } 
    else if (address == 0x2005) {         
    	write_SCROLL(value);
    } 
    else if (address == 0x2006) {
        write_VRAMADDR(value);
    } 
    else if (address == 0x2007) {
        write_VRAMDATA(value);
    } else if (address == 0x4014) {
    	write_OAMDMA(value);
    }
}

void reset_ppu()
{
	PPUCTRL = 0;
	PPUMASK = 0;
	PPUSCROLL = 0;
	PPUDATA = 0;

	PPUSTATUS = PPUSTATUS & 0x80;
	ppu_cycles = 0;
}

void normalize_address(uint16_t address)
{
	address &= 0x3FFF; //any address above 0x3FFF wraps around
	
	//address 0x3000 to 0x3EFF are mirrors of 0x2000 to 0x2EFF
	if(address >= 0x3000 && address <= 0x3EFF)
	{
		address -= 0x1000;
	}
	
	//addresses 0x3F20 to 0x3FFF are all mirrors of 0x3F00 to 0x3F1F
	if(address >= 0x3F20 && address <= 0x3F3F)
	{
		address -= 0x020;
	}
	else if(address >= 0x3F40 && address <= 0x3F5F)
	{
		address -= 0x040;
	}
	else if(address >= 0x3F60 && address <= 0x3F7F)
	{
		address -= 0x060;
	}
	else if(address >= 0x3F80 && address <= 0x3F9F)
	{
		address -= 0x080;
	}
	else if(address >= 0x3FA0 && address <= 0x3FBF)
	{
		address -= 0x0A0;
	}
	else if(address >= 0x3FC0 && address <= 0x3FDF)
	{
		address -= 0x0C0;
	}
	else if(address >= 0x3FE0 && address <= 0x3FFF)
	{
		address -= 0x0E0;
	}

	//for img and sprite palette
	if(address == 0x3F04 || address == 0x3F08 || address == 0x3F0C || address == 0x3F10 || address == 0x3F14 || address == 0x3F18 || address == 0x3F1C)
	{
		address = 0x3F00;
	}
}

uint8_t read_STATUS()
{
	uint8_t data = PPUSTATUS;
	PPUSTATUS = PPUSTATUS & 0x7F;
	PPUADDR = 0;
	PPUDATA = 0;
	return data;
}

uint8_t read_OAMDATA()
{
	return PPU_OAM_MEMORY[OAMADDR];
}

uint8_t read_VRAMDATA()
{
	uint8_t data = PPU_VRAM_MEMORY[PPUADDR];
	if(PPUCTRL & 0x04)
	{
		PPUADDR += 32;
	}
	else
	{
		PPUADDR += 1;
	}

	return data;
}

void write_CTRL(uint8_t value)
{
	PPUCTRL = value;
}

void write_MASK(uint8_t value)
{
	PPUMASK = value;
}

void write_OAMADDR(uint8_t addr)
{
	OAMADDR = addr;
}

void write_OAMDATA(uint8_t value)
{
	PPU_OAM_MEMORY[OAMADDR] = value;
	OAMADDR++;
}

void write_SCROLL(uint8_t value)
{
	if(x_or_y_scroll)
	{
		//first write
		x_offset = value & 0x07;
	}
	else
	{
		y_offset = value;
	}

	x_or_y_scroll = !x_or_y_scroll;
}

void write_VRAMADDR(uint8_t value)
{
	if(addr_write)
	{
		PPUADDR = value << 8;
	}
	else
	{
		PPUADDR = (PPUADDR & 0xF0) | value;
	}

	addr_write = !addr_write;
}

void write_VRAMDATA(uint8_t value)
{
	PPU_VRAM_MEMORY[PPUADDR] = value;
	if(PPUCTRL & 0x04)
	{
		PPUADDR += 32;
	}
	else
	{
		PPUADDR += 1;
	}
}

void write_OAMDMA(uint8_t value) {
	OAMDMA = value;
}
